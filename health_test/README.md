# Health check

## Clone repo
```
git clone git@github.com:usnistgov/SP800-90B_EntropyAssessment.git
```

## Compiling SP800-90b 

- Use aarch64-linux-gnu compiler

### Building openssl library

- openssl
```
wget https://www.openssl.org/source/openssl-1.1.1e.tar.gz
tar zxf openssl-1.1.1e.tar.gz
```

- Building
```
cd openssl-1.1.1e
./Configure linux-aarch64 --cross-compile-prefix=aarch64-linux-gnu- -static
make install
```

### Building libdivsufsort libarary

- Clone library
```
git clone git@github.com:y-256/libdivsufsort.git
```

- Create a build directory in the package source directory
```
cd libdivsufsort
mkdir build
cd build
```
- Configure system 
```
cmake .. \
    -DCMAKE_SYSTEM_NAME=Generic \
    -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
    -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_DIVSUFSORT64=ON
```

- Compile the package
```
make
```

### Building libjsoncpp library

- Clone library
```
git clone https://github.com/open-source-parsers/jsoncpp.git
cd jsoncpp
```

- Create build directory
```
mkdir build
cd build
```

- Configure 
```
cmake .. \
    -DCMAKE_SYSTEM_NAME=Linux \
    -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
    -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_SHARED_LIBS=ON \
    -DBUILD_TESTING=OFF
```

- Build library
```
make
```

### Building openssl library - none-elf

- export PATH=/home/dstorer/SP800-90B_EntropyAssessment/gcc-arm-10.2-2020.11-x86_64-aarch64-none-elf/bin:$PATH

- openssl
```
wget https://www.openssl.org/source/openssl-1.1.1e.tar.gz
tar zxf openssl-1.1.1e.tar.gz
```

- Building
```
cd openssl-1.1.1e
./Configure no-asm no-sock no-threads no-shared no-syslog linux-aarch64 --cross-compile-prefix=aarch64-none-elf- -static
make
```

### Building libdivsufsort libarary - none-elf

- Clone library
```
git clone git@github.com:y-256/libdivsufsort.git
```

- Create a build directory in the package source directory
```
cd libdivsufsort
mkdir build
cd build
```
- Configure system 
```
cmake .. \
    -DCMAKE_SYSTEM_NAME=Generic \
    -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_DIVSUFSORT64=ON
```

- Compile the package
```
make
```

### Building libjsoncpp library - none-elf

- Clone library
```
git clone https://github.com/open-source-parsers/jsoncpp.git
cd jsoncpp
```

- Create build directory
```
mkdir build
cd build
```

- Configure 
```
cmake .. \
    -DCMAKE_SYSTEM_NAME=Linux \
    -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \
    -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_SHARED_LIBS=ON \
    -DBUILD_TESTING=OFF
```

- Build library
```
make
```

### Buidling SP800-90B program

```
make ARCH=aarch64 CROSS_COMPILE=aarch64-linux-gnu-
```

### Building SP800-90B with c_interface on x86 linux
- Compile c++ file 
```
g++ -c non_iid_test.cpp -o non_iid_test.o
```

- Compile c interface 
```
gcc -c c_interface.c -o c_interface.o
```

- Link together
```
g++ c_interface.o non_iid_test.o -o main_program -ldivsufsort -ldivsufsort64
```


## To Do
- New main file for the long term health tests for microkit
- Run the long term health tests on linux without json output so can see how to output without json

## Things tried
- Compiled everything in the docker environment

## Client meeting
- Each HSM generates 20,0000 bits 
- Single place for each continuous test
- If the continous tests have reached the threshold for failure in the window the flow goes to the long term tests. 
- Some state needs to be kept between reboots. Bare minimum that needs to be kept in the state is the number of times the system has been booted.
- Continuous test has hard coded thresholds. After the continuous test have reached the failed request another sample of entropy from the HSM. If the continuous fails twice in a row it triggers the long term health test. 
- Once the hsm entropy tests go below a certain threshold the program has failed the hsm is dead and needs to be replaced. And the whole system fails. 
- Don't store any state 

### Conditioner
- Alogrithm kmac256 -> kmx256(K,L,S,X)
    - K -> key (Concatenation of first two HSM's entropy, size is 4096 bits)
    - L -> length of output (512 bits)
    - S -> context (from user and maaxboard entropy)
    - X -> input (Concatenation of last two HSM's entropy, size is 4096 bits)
- The conditioner takes the entropy, some entropy generated by the maaxboard and the some user defined entropy (context).
- Context is encoding of data from the user (what they are using it for, favourite colour) combined with the Maaxboard entropy. Also the Maaxboard entropy changes per request.


